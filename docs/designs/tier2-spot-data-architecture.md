# SpotDiggz データアーキテクチャ再設計 — Tier 1/2 分離とデータパイプライン導入

📅 作成日: 2026-02-28
👥 参加者: 白鐘直斗（設計・要件定義）、玉縄（UI/UX）
📋 ステータス: 設計完了・実装フェーズ移行待ち

---

## 1. 背景と目的

SpotDiggzのスポットデータを2つのティアに分離し、それぞれに最適なストレージ戦略を適用する。
同時に、マスターデータの投入経路をAPI経由からデータパイプライン（ETL）に転換し、
Firestoreを読み取り専用の配信ストアとして再定位する。

### 解決する課題

- ユーザー個人データのプライバシー確保（サービス提供者から不可視）
- クラウドリソースコストの抑制（ユーザー数に比例しない設計）
- マスターデータの品質管理（管理者によるキュレーション経路の確立）
- App Storeガイドライン 5.1.1(v) アカウント削除要件への対応

---

## 2. データティア定義

| 項目 | Tier 1: マスターデータ | Tier 2: ユーザー個人データ |
|:--|:--|:--|
| 内容 | 日本の主要スケートパーク・ストリートスポット | ユーザーが個人的にプロットしたスポット |
| 品質 | 管理者がキュレーション。Instagram URL / 公式サイト / 営業時間 / セクション情報あり | 最低限（位置情報 + スポット名）。その他は任意 |
| ストレージ | Firestore（読み取り専用配信） | iOS SwiftData + CloudKit（オプション同期） |
| 可視性 | 全ユーザーに公開 | 作成者本人のみ |
| 投入経路 | BigQuery → Cloud Functions → Firestore（管理者バッチ） | iOS端末上でユーザーが直接登録 |
| 削除 | 管理者のみ | ユーザーのアカウント削除時に自動削除 |

---

## 3. アーキテクチャ概要

```
〔データ加工層〕— 管理者のみがアクセス
  管理者
    ↓ CSV / スプレッドシートでスポット情報をキュレーション
    ↓
  BigQuery（データウェアハウス）
    ↓ 品質チェック・加工・整形
    ↓
  Cloud Functions（トリガー: スケジュール or 手動）
    ↓ Firestore に書き込み
    ↓
〔配信層〕— ユーザーからの読み取りリクエストを処理
  Firestore（Tier 1 マスターデータ専用・読み取り配信）
    ↓
  Rust API（読み取り専用エンドポイント）
    ↓
  iOS アプリ（Tier 1 表示）

〔ユーザーデータ層〕— 端末ローカル + オプションiCloud同期
  iOS SwiftData（Tier 2 スポット + マイリスト）
    ↔ CloudKit / iCloud（オプション同期・バックアップ）
```

### 設計原則

- Firestoreへのユーザー書き込み経路は【存在しない】
- iOS側からFirestoreへの直接アクセスは【読み取りのみ】（Rust API経由）
- ユーザー個人データ（Tier 2 + マイリスト）はサービス提供者のインフラに保存されない
- マスターデータの更新頻度は低い（週次〜月次のバッチ投入）

---

## 4. 要件整理

### 4.1 機能要件

📋 Tier 2 スポット機能（iOS）:
- [ ] `Tier 2` スポットのCRUD（作成・読取・更新・削除）をSwiftDataで実装
- [ ] `Tier 2` スポットへの画像添付（ローカル保存、`@Attribute(.externalStorage)` 使用）
- [ ] iCloudオン時のCloudKit同期（端末間引き継ぎ・アンインストール後の復元）
- [ ] iCloudオフ時の注意表示（「iCloudを有効にするとバックアップできます」）
- [ ] アカウント削除時に `Tier 2` データ（ローカル + CloudKit）を完全削除

📋 マイリスト機能（iOS）:
- [ ] マイリストのストレージをFirestore APIからSwiftData + CloudKitに移行
- [ ] オフラインでのマイリスト閲覧対応
- [ ] 「お気に入りに追加」の即時フィードバック（ハプティック + アニメーション）

📋 地図表示（iOS）:
- [ ] `Tier 1` / `Tier 2` スポットの混在表示
- [ ] ピンのビジュアルヒエラルキー（Tier 1 優先表示、Tier 2 は控えめ）
- [ ] 「マイスポット表示/非表示」フィルタトグル

📋 データパイプライン（インフラ）:
- [ ] BigQueryデータセットの作成（`sdz-dev` プロジェクト内）
- [ ] マスターデータ用テーブルスキーマの定義
- [ ] Cloud Functions: BigQuery → Firestoreへのデータ同期トリガー
- [ ] バッチ投入スクリプト（CSV → BigQuery ロード）

📋 Firestore読み取り専用化（インフラ）:
- [ ] Cloud Run サービスアカウントのIAM権限を `roles/datastore.viewer` に変更
- [ ] Firestoreセキュリティルールの読み取り専用化

📋 Rust API整理（バックエンド）:
- [ ] 書き込みエンドポイント（POST/PATCH spots, mylists）を休眠化（削除はしない）
- [ ] 読み取りエンドポイントの動作確認

### 4.2 非機能要件

- パフォーマンス: `Tier 2` はローカル読み取りで遅延なし。`Tier 1` はAPI経由（Firestore 10-100ms）
- コスト: `Tier 2` のクラウドリソース消費ゼロ。Firestoreは無料枠内。BigQuery無料枠（1TB/月クエリ、10GB保存）
- セキュリティ: `Tier 2` データはサービス提供者から不可視。Firestoreユーザー書き込み経路なし
- App Store準拠: ガイドライン 5.1.1(v) アカウント削除要件対応。Apple推奨技術スタック（SwiftData + CloudKit）

### 4.3 技術スタック

| レイヤー | 技術 | 用途 |
|:--|:--|:--|
| iOS ローカルDB | SwiftData | Tier 2 スポット + マイリスト永続化 |
| iOS クラウド同期 | CloudKit（SwiftData連携） | iCloud経由のバックアップ・端末間同期 |
| 配信DB | Firestore（Native モード） | Tier 1 マスターデータ配信（読み取り専用） |
| API | Rust（スクラッチ） | Tier 1 データの読み取りエンドポイント |
| データ加工 | BigQuery | マスターデータのETL・品質管理 |
| データ同期 | Cloud Functions（第2世代） | BigQuery → Firestore へのデータ投入 |
| 認証 | Firebase Auth / Identity Platform | Google Sign-In / Apple ID |

---

## 5. UXデザイン（玉縄レビュー済み）

### 5.1 ピンのビジュアルヒエラルキー

地図上のピン表示は2軸で区別する。

📋 第1軸（形状 + アイコン）: スポットタイプの区別
- パーク → 丸みのあるピン + スケートパークアイコン
- ストリート → 角張ったピン + ストリートアイコン

📋 第2軸（サイズ + カラー）: データティアの区別
- `Tier 1`（マスター）→ フルカラー、標準サイズ。メインコンテンツとしてのプレゼンス
- `Tier 2`（ユーザー）→ 小さめ、セカンダリカラー（グレー系 or パステル）。「自分だけのメモ」感

```
〔地図上のピン表示イメージ〕

  🛹  Tier 1 パーク: フルカラー、標準サイズ、リッチなアイコン
  🔶  Tier 1 ストリート: フルカラー、標準サイズ

  📌  Tier 2（ユーザー）: シンプルなピン、小さめ、グレー系 or パステル
       タップするとラベルに「マイスポット」と表示
```

📋 設計意図（玉縄）:
- SpotDiggzのコアバリューは `Tier 1` マスターデータによる「信頼できるスポット発見」
- `Tier 2` はパーソナルなサブ機能。ビジュアルでも `Tier 1` を優先する
- ユーザーが「公式情報」と「自分のメモ」を混同しない設計

### 5.2 フィルタリング

検索・フィルタパネル（P1-1）に以下のトグルを追加:
- 「マイスポットを表示」（デフォルト: ON）
- 「マスターデータのみ表示」（マイスポットを非表示にするショートカット）

### 5.3 マイリスト移行のUXインパクト

📋 ポジティブ:
- オフラインでマイリスト閲覧可能
- ローカル読み取りで表示が高速化
- 「お気に入りに追加」が即座に反映（API待ちなし）

📋 ケアすべき点:
- iCloudオフのユーザーは端末変更時にマイリストが失われる
  → Tier 2 スポットと同じ注意表示でカバー
- 既存ユーザーのFirestoreマイリストデータのマイグレーション
  → リリース前のため対応不要（アクティブユーザーなし）

---

## 6. API エンドポイントの役割変更

| エンドポイント | メソッド | 新設計での役割 | ステータス |
|:--|:--|:--|:--|
| `/sdz/health` | GET | ヘルスチェック | ✅ 変更なし |
| `/sdz/users/me` | GET | 認証・プロファイル取得 | ✅ 変更なし |
| `/sdz/spots` | GET | Tier 1 マスターデータ一覧配信 | ✅ 変更なし |
| `/sdz/spots/{id}` | GET | Tier 1 スポット詳細配信 | ✅ 変更なし |
| `/sdz/spots` | POST | — | 💤 休眠（将来のTier昇格で再利用の可能性） |
| `/sdz/spots/{id}` | PATCH | — | 💤 休眠 |
| `/sdz/spots/upload-url` | POST | — | 💤 休眠（Tier 2 画像はローカル保存） |
| `/sdz/mylists/*` | ALL | — | 💤 休眠（SwiftData + CloudKitに移行） |

---

## 7. 実装フェーズ

### Phase 1: インフラ基盤構築（最優先）

📋 目的: BigQueryとデータパイプラインの環境を整備する

- [ ] BigQueryデータセット作成（Terraform）
- [ ] マスターデータ用テーブルスキーマ定義（spots テーブル）
- [ ] サンプルマスターデータ5件をBigQueryに投入
- [ ] Firestoreの IAM 権限を読み取り専用に変更
- [ ] 既存Terraformの整合性確認・更新

### Phase 2: データ配信パイプライン構築

📋 目的: BigQuery → Firestoreへの自動データ同期を確立する

- [ ] Cloud Functions（第2世代）のデプロイ基盤構築（Terraform）
- [ ] BigQuery → Firestoreデータ同期関数の実装
- [ ] トリガー方式の決定（スケジュール / 手動 / Pub/Sub）
- [ ] パイプラインの動作確認（サンプルデータ5件がFirestoreに反映されること）

### Phase 3: バックエンド・ドキュメント整理

📋 目的: Rust APIの役割変更とリポジトリ全体の整合性を確保する

- [ ] Rust API: 書き込みエンドポイントの休眠化
- [ ] Rust API: 読み取りエンドポイントの動作確認（パイプライン投入データで検証）
- [ ] ドキュメント一括更新（CLAUDE.md, 各設計書, seed_runbook 等）
- [ ] 不整合のあるGitHub Issuesの更新・クローズ

### Phase 4: iOS実装

📋 目的: SwiftData + CloudKit による Tier 2 機能と、UIの刷新

- [ ] SwiftData モデル定義（`SdzLocalSpot`, `SdzLocalMyList`）
- [ ] CloudKit連携の設定（`ModelConfiguration` + `cloudKitDatabase`）
- [ ] Tier 2 スポットCRUD画面の実装
- [ ] Tier 2 スポットへの画像添付機能
- [ ] マイリストのSwiftData移行
- [ ] 地図上のTier 1 / Tier 2 混在表示とピンデザイン
- [ ] フィルタ「マイスポット表示/非表示」トグル追加
- [ ] iCloudオフ時の注意表示
- [ ] アカウント削除時のデータクリア処理

---

## 8. スコープ外（今回やらないこと）

- `Tier 2` → `Tier 1` 昇格機能（将来の拡張ポイントとして残す）
- Firestoreへのユーザー書き込み経路（現時点では不要）
- 管理者用Web UI（バッチスクリプト / BigQueryコンソールで代替）
- API書き込みエンドポイントの削除（休眠させるだけで保持）
- Webフロントエンド（React UI）の改修（iOS優先）

---

## 9. 将来の拡張ポイント

- `Tier 2` → `Tier 1` 昇格: 承認ワークフロー追加。Firestoreへの書き込み経路を開放
- API書き込みエンドポイントの管理者限定化（ロールベースアクセス制御）
- BigQuery上でのマスターデータ分析ダッシュボード
- Android版への展開（SwiftData → Room + WorkManager で同等の構成）

---

## 10. 関連ドキュメント

- `docs/designs/ui-redesign-discovery-app.md` — UIリデザイン設計書（玉縄・直斗、2026-02-24）
- `CLAUDE.md` — プロジェクト設定（API/インフラ/コマンド定義）
- `iOS/SDZ_IOS_DESIGN.md` — iOS実装設計書
- `docs/api_architecture.md` — API設計書
- `docs/seed_runbook.md` — マスターデータ投入手順

---

## ヒアリングログ

1. ユーザーからスポットデータのティア分け（Tier 1 / Tier 2）とローカルストレージ保存の要望を受領
2. 現行コードベースを調査。承認/未承認ステータス・ティアシステム・ローカルストレージ（CoreData/SwiftData）は未実装であることを確認
3. データ永続性・ストレージ技術・画像・地図表示の4点を確認
4. ユーザーから「アプリ削除ではデータを残し、アカウント削除時のみ削除」の要件を受領
5. iOSサンドボックスの制約を説明。SwiftData + CloudKitの方式を提案
6. Firestoreの役割縮小について議論。BigQuery代替案を検討したが、配信DBとしてのレイテンシ問題を指摘
7. 2層アーキテクチャ（データ加工層 + 配信層）で合意
8. マイリストについて玉縄の設計書を確認。明示的な削除判断なし。維持の方向で整理
9. 玉縄の設計書に既存のTier定義があり、今回の方針と整合していることを確認
10. 玉縄によるUXレビュー完了。ピンのビジュアルヒエラルキーとマイリスト移行のUXインパクトを整理
11. 実装フェーズを4段階に整理。インフラ基盤（BigQuery + パイプライン）を最優先とすることで合意
